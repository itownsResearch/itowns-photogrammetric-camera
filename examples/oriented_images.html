
<html>
    <head>
        <title>Itowns - Oriented image</title>
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <style type="text/css">
            #info {
                color: black;
                position: absolute;
                bottom: 0;
                right: 0;
                margin-right: 15px;
                padding: 0.3rem;
                background-color: rgba(255, 255, 255, 0.493);
                border: 2px solid black;
                border-radius: 5px;
            }
        </style>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="js/GUI/dat.gui/dat.gui.min.js"></script>
        <script src="js/OrientedImageHelper.js"></script>
    </head>
    <body>
        <div id="viewerDiv">
            <p id="info">
                Add picture licence here
                <a href="add reference to the picture" target="_blank"> link </a>
            </p>
        </div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
       <!-- <script src="../../src/photogrammetic_camera/three-photogrammetric-camera.js"></script>  -->
        <script type="text/javascript">


            // Get possible parameters from url like imagename
            var parameters = location.search.substring(1).split("&");
            var temp = parameters[0].split("=");
            var imName = unescape(temp[1]);
            console.log(imName);

            // THREE photogrammetric camera variables
            var PhotogrammetricCamera = itowns.PhotogrammetricCamera;
           // console.log("PhotogrammetricCamera", PhotogrammetricCamera);
            var MicmacOrientationParser = itowns.MicmacOrientationParser;
            var FetchSource = itowns.FetchSource;
            var OrientedImageMaterial = itowns.OrientedImageMaterial;
            var THREE = itowns.THREE;

            // Define initial camera position.
            // Note that camera initial position will be overwritten by picture position later
            var dummyPositionOnGlobe = { longitude: 0, latitude: 0, altitude: 10000000 };

            // viewerDiv will contain iTowns rendering area
            var viewerDiv = document.getElementById('viewerDiv');

            // Instanciate iTowns GlobeView
            var view = new itowns.GlobeView(viewerDiv, dummyPositionOnGlobe, {
                sseSubdivisionThreshold: 6,
                noControls: false,
                handleCollision: false
            });

            var pictureInfos;
            var camera;
            var cameraHelper;
            var plane;
            var orientedImage;
            var orientedImageGUI;
            var orientedMenu = false;
            var currentIndiceNav = 0;
            var meshes = [];
            var scaler;
            var textureMaterial;

            // Alex modifications to handle multiple images
            var arrayImages = [];
            arrayImages = [{image: '1919_CAF_C-1_0012.jpg', distance: 200, opacity: 1, plane:null}, 
                           {image: '1951_DUR_208_0007.jpg', distance: 200, opacity: 1, plane:null},
                           {image: '1951_DUR_214_0024.jpg', distance: 200, opacity: 1, plane:null}, 
                           {image: '1951_DUR_214_0022.jpg', distance: 200, opacity: 1, plane:null},
                           {image: '1919_defile_victoire.jpg', distance: 200, opacity: 1, plane:null},
                           {image: '1919_CAF_Z-36_0008.jpg', distance: 200, opacity: 1, plane:null}];
                           

            if(imName !== 'undefined')
                arrayImages.unshift(  {image: imName, distance: 100, opacity: 1, plane:null} );
            
                  // Add one imagery layer to the scene
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });

            // Add two elevation layers.
            // These will deform iTowns globe geometry to represent terrain elevation.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);


            var color = new itowns.THREE.Color();
            var tile;

            function colorBuildings(properties) {
                if (properties.id.indexOf('bati_remarquable') === 0) {
                    return color.set(0x5555ff);
                } else if (properties.id.indexOf('bati_industriel') === 0) {
                    return color.set(0xff5555);
                }
                return color.set(0xeeeeee);
            }

            function altitudeBuildings(properties) {
                return properties.z_min - properties.hauteur;
            }

            function extrudeBuildings(properties) {
                return properties.hauteur;
            }

            function acceptFeature(properties) {
                return !!properties.hauteur;
            }

            scaler = function update(/* dt */) {
                var i;
                var mesh;
                if (meshes.length) {
                    view.notifyChange(view.camera.camera3D, true);
                }
                for (i = 0; i < meshes.length; i++) {
                    mesh = meshes[i];
                    if (mesh) {
                        mesh.scale.z = Math.min(
                            1.0, mesh.scale.z + 0.1);
                        mesh.updateMatrixWorld(true);
                    }
                }
                meshes = meshes.filter(function filter(m) { return m.scale.z < 1; });
            };

            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, scaler);

            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '2.0.0',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                projection: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json',
                zoom: { min: 15, max: 15 },
              
            });

            var wfsBuildingLayer = new itowns.GeometryLayer('WFS Building', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    color: colorBuildings,
                    batchId: function (property, featureId) { return featureId; },
                    altitude: altitudeBuildings,
                    extrude: extrudeBuildings }),
                onMeshCreated: function scaleZ(mesh) {
                    mesh.scale.z = 0.01;
                    meshes.push(mesh);
                    mesh.material = textureMaterial;
                },
                filter: acceptFeature,
                overrideAltitudeInToZero: true,
                source: wfsBuildingSource
            });
            view.addLayer(wfsBuildingLayer);



/*
            
            var wfsAlex = new itowns.WFSSource({
                url: 'http://del1101w005.ign.fr:8081/geoserver/ows?',
                version: '2.0.0',
                typeName: 'alex',
                projection: 'EPSG:4326',
                ipr: 'Alegoria',
                format: 'application/json',
                zoom: { min:5, max: 18 },
              
            });

            var wfsAlexLayer = new itowns.GeometryLayer('WFS Alex', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    color: colorBuildings,
                    batchId: function (property, featureId) { return featureId; },
                   // altitude: altitudeBuildings,
                    extrude: extrudeBuildings }),
              
                //filter: acceptFeature,
                //overrideAltitudeInToZero: true,
                source: wfsAlex
            });
            view.addLayer(wfsAlexLayer);

*/


            // global itowns, document, GuiTools, view, promises
            var menuGlobe = new GuiTools('menuDiv');
            var navMenu = menuNavigUI(menuGlobe, arrayImages);





            
                /* Orientation loading */
                function cameraHelper(camera, mat) {
                    var wireMaterial = new THREE.MeshBasicMaterial( {color: 0x00ffff, wireframe: true} );
                    // create the group (looking at intrinsics only) that should be added to the camera frame.
                    var group = new THREE.Group();
                    // place a frustum
                    {
                        m = new THREE.Matrix4().getInverse(camera.projectionMatrix);
                        var geometry = new THREE.BufferGeometry();
                        var vertices = new Float32Array(15);
                        // get the 4 corners on the near plane (neglecting distortion)
                        new THREE.Vector3( -1, -1, -1 ).applyMatrix4(m).toArray(vertices,  3);
                        new THREE.Vector3( -1,  1, -1 ).applyMatrix4(m).toArray(vertices,  6);
                        new THREE.Vector3(  1,  1, -1 ).applyMatrix4(m).toArray(vertices,  9);
                        new THREE.Vector3(  1, -1, -1 ).applyMatrix4(m).toArray(vertices, 12);
                        var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                        geometry.setIndex( indices );
                        geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                        geometry.addGroup(0, 12, 0);
                        geometry.addGroup(12, 6, 1);
                       // viewMaterials[camera.name] = new OrientedImageMaterial(viewMaterialOptions);
                       // viewMaterials[camera.name].map = textures[camera.name] || uvTexture;
                        mat.map = uvTexture;
                        var mesh = new THREE.Mesh( geometry, [wireMaterial, mat] );
                        mesh.scale.set(1000, 1000, 1000);
                        group.add(mesh);
                    }
                    // place a sphere at the camera center
                    {
                        var geometry = new THREE.SphereBufferGeometry(0.03, 8, 8 );
                        var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                        group.add(new THREE.Mesh( geometry, material ));
                    }
                    return group;
                };


                /*
            function setMaterial(material, camera) {
                    material.map =  uvTexture;
                    material.uvwPreTransform.copy(camera.preProjectionMatrix).multiply(camera.matrixWorldInverse);
                    material.uvwPostTransform.copy(camera.postProjectionMatrix);
                    if (camera.distos && camera.distos.length == 1 && camera.distos[0].type === 'ModRad') {
                        material.uvDistortion = camera.distos[0];
                    } else {
                        material.uvDistortion = { C: new THREE.Vector2(), R: new THREE.Vector4() };
                        material.uvDistortion.R.w = Infinity;
                    }
                }
                */

                function setMaterial(material, camera) {
                    material.map =  uvTexture; //textures[camera.name] || uvTexture;
                    camera.getWorldPosition(material.uvwPosition);
                    const m = new THREE.Matrix4().copy(camera.matrixWorldInverse);
                    m.setPosition({x:0,y:0,z:0});
                    material.uvwPreTransform.copy(camera.preProjectionMatrix).multiply(m);
                    material.uvwPostTransform.copy(camera.postProjectionMatrix);
                    if (camera.distos && camera.distos.length == 1 && camera.distos[0].type === 'ModRad') {
                        material.uvDistortion = camera.distos[0];
                    } else {
                        material.uvDistortion = { C: new THREE.Vector2(), R: new THREE.Vector4() };
                        material.uvDistortion.R.w = Infinity;
                    }
                }


            const uvTexture = new itowns.THREE.TextureLoader().load('../../data/uv.jpg');

            // function to handle micmac orientation file
            function handleOrientation(cam) {

                textureMaterial = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load('../../data/uv.jpg'), // uvTexture,
                    opacity:1.,
                    transparent:true,
                   // size: 2,
                 //   vertexColors: THREE.VertexColors,
                 //  sizeAttenuation: false,
                    //blending: THREE.NormalBlending,
                });

             
                setMaterial(textureMaterial, cam);
                console.log(textureMaterial);
                
                sphere = new THREE.Mesh(new THREE.SphereBufferGeometry(-3, 32, 32), textureMaterial);
            //    sphere.position.copy(cam.position);
            //    sphere.updateMatrixWorld();
                cam.add(sphere);

                plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000000, 20000000), textureMaterial);
                view.scene.add(plane);

             //   cam.updateMatrixWorld();
             //   view.scene.add(sphere);//cam);
/*
                var c = cameraHelper(cam, textureMaterial);
                c.position.copy(cam.position);
                c.updateMatrixWorld();
                view.scene.add(c);
*/
                cam.add(cameraHelper(cam, textureMaterial));
                cam.updateMatrixWorld();
                view.scene.add(cam);  
                console.log(cam);
                var pictureInfos = arrayImages[currentIndiceNav];
                // camera set from micmac orientation file
                camera = cam;
                if(pictureInfos.plane == null){
                    plane = setupPictureFromCamera(camera, '../../data/' + pictureInfos.image, pictureInfos.opacity, pictureInfos.distance); // plane is added to the photogra camara (so the scene)
                    pictureInfos.plane = plane;
                }else{
                    plane = pictureInfos.plane;
                }
                
                console.log("zdzdzdz", plane);
                var p2 = plane.clone();
                p2.position.multiplyScalar(1.0001);
                p2.updateMatrixWorld();
                view.scene.add(p2);

                textureMaterial.map = new itowns.THREE.TextureLoader().load('../../data/' + pictureInfos.image);

                updateCamera();

                /*
                // create 3D object and add it to scene
                orientedImage = new itowns.THREE.Object3D();
                view.scene.add(orientedImage);
                orientedImage.add(camera);
                */

                // open view camera FOV of 10° to see landscape around the picture.
                //   view.camera.camera3D.fov += 10;
                view.camera.camera3D.updateProjectionMatrix();
                console.log(view.camera.camera3D);

        //        view.camera.camera3D = cam;

                // set GUI for oriented image
                if(!orientedMenu){
                     orientedImageGUI = setupPictureUI(menuGlobe, pictureInfos, plane, updatePlaneDistance, updatePlaneOpacity, view, 50, 4000);  
                     orientedMenu = true; 
                    // console.log(menuGlobe.gui.__folders["Oriented Image"].__controllers[0]);
                }else{
                   // menuGlobe.gui.__folders["Oriented Image"].__controllers[0].object.plane = plane;
                   // menuGlobe.gui.__folders["Oriented Image"].__controllers[0].object.distance = pictureInfos.distance;
                }
                view.notifyChange(view.camera.camera3D);

               // console.log(camera);
            }
            
            // fetch orientation file
            var source = new FetchSource('../../outputs/test/');
            // parse micmac orientation
            source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                .then(data => MicmacOrientationParser.parse(data, source))
                .then(handleOrientation);


            function updatePlaneDistance(value) {
                transformTexturedPlane(camera, value, plane);//, pictureInfos.opacity);
                view.notifyChange(view.camera.camera3D);
            }
           
            function updatePlaneOpacity(value) {
                console.log(value, plane);
                plane.material.opacity = value;
                textureMaterial.opacity = value;
                view.notifyChange(view.camera.camera3D);
            }

            // update camera and view
            function updateCamera() {
                setupViewCameraDecomposing(view, camera);
                //if (cameraHelper) cameraHelper.updateMatrixWorld(true);
                view.notifyChange(view.camera.camera3D);
            }

            
            // eslint-disable-next-line no-unused-vars
            function menuNavigUI(menu, pictureInfos) {
                var navImageGUI = menu.gui.addFolder('Navigation Image');
                var obj = { next:function(){ nextImage() }};
                navImageGUI.add(obj,'next');
                view.notifyChange(view.camera.camera3D);
            }

      
            function nextImage(){
                
                currentIndiceNav = (currentIndiceNav + 1) % arrayImages.length; console.log("currentIndiceNav ",currentIndiceNav);
                console.log('indice image: ', currentIndiceNav);

                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                .then(data => MicmacOrientationParser.parse(data, source))
                .then(handleOrientation);
                //view.notifyChange();
            }



            // add debugging tools to GUI
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);


            // Ugly way to force refreshing the view 
            var time = 0;
            function updateView() {
               time++;
               if(time % 100 == 0)
                    view.notifyChange(view.camera.camera3D);
               window.requestAnimationFrame(updateView); 
            }

            updateView();

        </script>
    </body>
</html>
